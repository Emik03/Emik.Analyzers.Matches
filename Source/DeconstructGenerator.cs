// SPDX-License-Identifier: MPL-2.0
namespace Emik.Analyzers.Matches;

/// <summary>Generates the attribute needed to use this analyzer.</summary>
[Generator]
public sealed class DeconstructGenerator : ISourceGenerator
{
    /// <summary>Gets the contents to generate a source of.</summary>
    public static string Contents { get; } = Methods();

    /// <inheritdoc />
    public void Execute(GeneratorExecutionContext context) =>
        context.AddSource("Emik.DeconstructGenerator.g.cs", Contents);

    /// <inheritdoc />
    public void Initialize(GeneratorInitializationContext context) { }

    static string Methods() =>
        CSharp(
            0,
            $$"""
            // <auto-generated/>
            // ReSharper disable RedundantNameQualifier
            // ReSharper disable once CheckNamespace
            namespace Emik
            {
                /// <summary>Declares a contract that the generic parameter must include the qualified member.</summary>
                internal static class MatchDeconstructors
                {
            {{(1..16).For().Select(Method).Conjoin("\n\n")}}
                }
            }
            """
        );

    static string Method(int i) =>
        CSharp(
            2,
            $$"""
            public static void Deconstruct(
                this global::System.Text.RegularExpressions.Match match,
            {{Parameter(i)}}
            )
            {
            {{ParameterBody(i)}}
            }
            """
        );

    static string Parameter(int i) =>
        i.For(x => CSharp(1, $"out global::System.Text.RegularExpressions.Capture n{x}")).Conjoin(",\n");

    static string ParameterBody(int i) => i.For(x => CSharp(1, $"n{x} = match.Captures[{x}];")).Conjoin("\n");

    static string CSharp(int indent, [StringSyntax("C#")] string code) =>
        code
           .Split('\n')
           .Select(x => $"{new string(' ', indent * 4)}{x}")
           .Conjoin('\n');
}
